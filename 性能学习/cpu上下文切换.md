

而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，
也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）。


CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，
则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。
它们都是 CPU 在运行任何任务前，必须的依赖环境，    
因此也被叫做 CPU 上下文




CPU 上下文切换。CPU 上下文切换，
就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，
然后加载新任务的上下文到这些寄存器和程序计数器，
最后再跳转到程序计数器所指的新位置，运行新任务。


所以，根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，
也就是进程上下文切换、线程上下文切换以及中断上下文切换

cpu上下文切换包括
  
    进程上下文切换和中断上下文切换
    
#进程上下文切换
   
cpu特权等级
    ring 0 --ring 3
    
    用户态到内核态的转换，需要系统调用来完成
    
  系统调用也有上下文切换
  
区别：
  	
		进程上下文切换时在进程之间的
		系统调用的是在同一进程的上下文切换
		
		
		
不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，
也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：
 进程上下文切换，是指从一个进程切换到另一个进程运行。 
  而系统调用过程中一直是同一个进程在运行。
   所以，系统调用过程通常称为特权模式切换，而不是上下文切换。   
   但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的
   
   
   
   
   那么，进程在什么时候才会被调度到 CPU 上运行呢？
最容易想到的一个时机，就是进程执行完终止了，它之前使用的 CPU 会释放出来，这
个时候再从就绪队列里，拿一个新的进程过来运行。其实还有很多其他场景，也会触发
进程调度，在这里我给你逐个梳理下。

	其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这
	些时间片再被轮流分配给各个进程。
	这样，当某个进程的时间片耗尽了，就会被系统挂
	起，切换到其它正在等待 CPU 的进程运行。
	
	其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个
	时候进程也会被挂起，并由系统调度其他进程运行。
	
	其三，当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调
	度。
	
	其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂
	起，由高优先级进程来运行。
	
	最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服
	务程序。

了解这几个场景是非常有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后
凶手。


#线程上下文切换


线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单
位。

	说白了，所谓内核中的任务调度，实际上的调度对象是线程；
	而进程只是给线程提供了虚拟内存、全局变量等资源。

所以，对于线程和进程，我们可以这么理解：

当进程只有一个线程时，可以认为进程就等于线程。
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些
资源在上下文切换时是不需要修改的。
另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需
要保存的。
这么一来，线程的上下文切换其实就可以分为两种情况：
第一种， 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进
程上下文切换是一样。   
第二种，前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换
时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数
据。   

到这里你应该也发现了，虽然同为上下文切换，但同进程内的线程切换，要比多进程间
的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势



这个结果中有两列内容是我们的重点关注对象。
一个是 cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数，

另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。 

这两个概念你一定要牢牢记住，因为它们意味着不同的性能问题： 

	所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。
		比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
		
	 而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。
	 	比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
	 	
	
sysbench 是一款模拟系统多线程调度的的软件的情况








vmstat 主要分析系统的内存使用情况

	man vmstat:
	  
	  cs: The number of context switches per second.  每秒上下文切换次数
	  in: The number of interrupts per second, including the clock. 每秒终端次数
	  
	  r: The number of runnable processes (running or waiting for run time). 
	  			就绪队列长度，正在等待cpu或者运行的进程数
       b: The number of processes in uninterruptible sleep.
       			不可终端睡眠的进程数
       			
      
查看进程的上下文切换次数：
	
	man pidstat
	
	
	pidstat -w 5
	
	  cswch/s
                     Total number of voluntary context switches the task made per second. 
                      A voluntary context  switch  occurs  
                      when  a task blocks because it requires a resource that is unavailable.
	每秒任务所做的自愿上下文切换的总数。 
	当任务阻塞时会发生自愿上下文切换，
	因为它需要一个不可用的资源。



              nvcswch/s
                     Total number of non voluntary context switches the task made per second. 
                      A involuntary context switch takes place   
                         when a task executes for the duration of its time slice 
                         and then is forced to relinquish the processor.
	 
	 每秒任务所做的非自愿上下文切换的总数。
	  当任务在其时间片的持续时间内执行时，
	  发生非自愿的上下文切换，然后被迫放弃处理器。
	

#sysbench
	
	sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况
	
	
	
	sysbench --test=threads  --num-threads=10  --max-time=300 run
	
	pidstat -wt 1

	vmstat  1 2
	

查看中断信息：

	# -d 参数表示高亮显示变化的区域
	$ watch -d cat /proc/interrupts
	           CPU0       CPU1
	...
	RES:    2450431    5279697   Rescheduling interrupts


观察一段时间，你可以发现，变化速度最快的是重调度中断（RES），
这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，
调度器用来分散任务到不同 CPU 的机制，
通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）


这时，你还需要根据上下文切换的类型，再做具体分析。比方说：

 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题； 
 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
  中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。
  
  
  


	# 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）
	# -wt 参数表示输出线程的上下文切换指标
	$ pidstat -wt 1
	08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command
	...
	08:14:05        0     10551         -      6.00      0.00  sysbench
	08:14:05        0         -     10551      6.00      0.00  |__sysbench
	08:14:05        0         -     10552  18911.00 103740.00  |__sysbench
	08:14:05        0         -     10553  18915.00 100955.00  |__sysbench
	08:14:05        0         -     10554  18827.00 103954.00  |__sysbench
	...
	
	
#查看中断


	# -d 参数表示高亮显示变化的区域
	$ watch -d cat /proc/interrupts
	           CPU0       CPU1
	...
	RES:    2450431    5279697   Rescheduling interrupts
	...
	
	
现在再回到最初的问题，每秒上下文切换多少次才算正常呢？ 

这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。  
但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。 

这时，你还需要根据上下文切换的类型，再做具体分析。
	
	比方说： 
		自愿上下文切换变多了，
			说明进程都在等待资源，有可能发生了 I/O 等其他问题； 
			
		非自愿上下文切换变多了，
			说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈； 
			
		中断次数变多了，
			说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型

	
