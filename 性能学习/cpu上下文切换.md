

而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，
也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）。


CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，
则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。
它们都是 CPU 在运行任何任务前，必须的依赖环境，    
因此也被叫做 CPU 上下文




CPU 上下文切换。CPU 上下文切换，
就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，
然后加载新任务的上下文到这些寄存器和程序计数器，
最后再跳转到程序计数器所指的新位置，运行新任务。


所以，根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，
也就是进程上下文切换、线程上下文切换以及中断上下文切换

cpu上下文切换包括
  
    进程上下文切换和中断上下文切换
    
#进程上下文切换
   
cpu特权等级
    ring 0 --ring 3
    
    用户态到内核态的转换，需要系统调用来完成
    
  系统调用也有上下文切换
  
区别：
  	
		进程上下文切换时在进程之间的
		系统调用的是在同一进程的上下文切换
		
		
		
不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，
也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：
 进程上下文切换，是指从一个进程切换到另一个进程运行。 
  而系统调用过程中一直是同一个进程在运行。
   所以，系统调用过程通常称为特权模式切换，而不是上下文切换。   
   但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的
   
   
   
   
   那么，进程在什么时候才会被调度到 CPU 上运行呢？
最容易想到的一个时机，就是进程执行完终止了，它之前使用的 CPU 会释放出来，这
个时候再从就绪队列里，拿一个新的进程过来运行。其实还有很多其他场景，也会触发
进程调度，在这里我给你逐个梳理下。

	其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这
	些时间片再被轮流分配给各个进程。
	这样，当某个进程的时间片耗尽了，就会被系统挂
	起，切换到其它正在等待 CPU 的进程运行。
	
	其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个
	时候进程也会被挂起，并由系统调度其他进程运行。
	
	其三，当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调
	度。
	
	其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂
	起，由高优先级进程来运行。
	
	最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服
	务程序。

了解这几个场景是非常有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后
凶手。


#线程上下文切换


线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单
位。

	说白了，所谓内核中的任务调度，实际上的调度对象是线程；
	而进程只是给线程提供了虚拟内存、全局变量等资源。

所以，对于线程和进程，我们可以这么理解：

当进程只有一个线程时，可以认为进程就等于线程。
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些
资源在上下文切换时是不需要修改的。
另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需
要保存的。
这么一来，线程的上下文切换其实就可以分为两种情况：
第一种， 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进
程上下文切换是一样。   
第二种，前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换
时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数
据。   

到这里你应该也发现了，虽然同为上下文切换，但同进程内的线程切换，要比多进程间
的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势



这个结果中有两列内容是我们的重点关注对象。
一个是 cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数，

另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。 

这两个概念你一定要牢牢记住，因为它们意味着不同的性能问题： 

	所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。
		比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
		
	 而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。
	 	比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
	 	
	
sysbench 是一款模拟系统多线程调度的的软件的情况






